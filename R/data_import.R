
#' Loading DIA data from MaxQuant
#'
#' FOR INTERNAL UAMS USE, NEED TO UPDATE
#'
#' @param input_file The file of Maxquant data to be imported. Format and filetype
#'   vary depending on the type of data to be analyzed. If not supplied, R will
#'   ask you to pick a file from the file browser.
#' @param sample_IDs Optional: a vector of sample IDs to analyze. Default is NULL, in which
#'   case all sample IDs are analyzed. These are determined from column names.
#'
#' @return A prototype of our new S3 list type.
#'
#' @export
#'
#' @examples
#' # No examples yet
#'
read_DIA_data <- function(input_file = NULL,
                          sample_IDs = NULL) {


  ## if no file is input by user the open file dialog box is
  ## called to allow the user to navigate to and select the file.
  if (is.null(input_file)) {
    input_file <- file.choose()
  }



  ## IMPORT DATA
  ## the first 10 lines are skipped and last line removed. column 1 (.X)
  ## is renamed "id"
  maxquant_data <- read_maxquant_delim(input_file = input_file)
  rownames(maxquant_data) <- paste0("protein", 1:nrow(maxquant_data))

  # Separate out data columns (which end in .mzML)
  raw_data <- maxquant_data[,stringr::str_detect(colnames(maxquant_data), ".mzML$")]
  # And annotation columns (all other cols)
  raw_annotation <- maxquant_data[,stringr::str_detect(colnames(maxquant_data), ".mzML$", negate = T)]

  ## REPLACE MISSING VALUES WITH ZERO
  ## intensity data is not a numeric data.frame and requires
  ## additional processing numbers are character strings separated
  ## by commas (4,000,000), some cells contain text 'Missing Value'
  ## if the protein does not have detectable expression.
  ## replace 'Missing Value' with zeros, remove comma's, convert
  ## data in each column to numeric values
  raw_data[, ][raw_data[, ] == "Missing Value"] <- "0"

  clean_data <- as.data.frame(apply(raw_data, MARGIN = 2, remove_commas), row.names = rownames(raw_data))
  clean_annot <- extract_protein_data(raw_annotation)

  # For now, check that nrows are equal, but
  # TODO: remove this once the checker does it for us
  stopifnot(nrow(clean_data) == nrow(clean_annot))
  stopifnot(rownames(clean_data) == rownames(clean_annot))

  num_samples   <- ncol(clean_data)
  num_extracted <- nrow(clean_data)

  cli::cli_inform(c("Intensity data for {.val {num_extracted}} DIA protein entries and {.val {num_samples}} samples extracted"))

  cli::cli_inform(c("v" = "Success!!"))


  ## return a list of data.frame containing the extracted quality
  ## filtered intensity data, corresponding extracted annotation,
  ## stats, and input parameters
  out <- list(
    data = clean_data,
    annotation = clean_annot,
    metadata = NULL,
    design = NULL,
    eBayes_fit = NULL,
    results = NULL,
    tags = NULL
  )

  validate_DIAlist(new_DIAlist(out))
}



#' Import MaxQuant data
#'
#' First subfunction called by \code{\link{read_DIA_data}}. Reads in the tabular
#' data and does some checks for required columns.
#'
#' @inheritParams read_DIA_data
#'
#' @return a data frame, where each row is a (raw) protein, the first
#'        few columns are protein ID data, and the last columns are the individual
#'        sample intensities (as character vectors).
#'
#' @keywords internal
#'
#' @examples
#' # No examples yet

read_maxquant_delim <-function(input_file) {
  ## check that the file is a csv, tsv, or text file
  filext <- stringr::str_to_lower(file_extension(input_file))
  if (filext %notin% c("csv","txt","tsv")) {
    cli::cli_abort(c("Problem with input file",
                     "x" = "Input file must end in {.file .csv}, {.file .tsv}, or {.file .txt}"))
  }

  ## check that file exists
  if (!file.exists(input_file)) {
    cli::cli_abort(c("Cannot find file.",
                     "x" = "{.file {input_file}} does not exist",
                     "i" = "Did you specify the filepath correctly?"))
  }

  if(filext=="txt" | filext=="tsv"){ sep="\t" }
  if(filext=="csv"){ sep=","}


  ## sample report generated by scaffold DIA is imported as data.frame.
  ## Sample Reports generated by Scaffold DIA contain meta data in the
  ## first 10 lines, and text in the last row to mark the end of the file.
  ## Thus, when reading in the file the first 10 lines are skipped and the
  ## last row is removed. column name of column 1 (X. on import) is changed to id
  ## column 1 must be changed to "id" to allow extraction and other processing.
  ## Note: column names of the input file are defined according to R syntax rules.
  ## special characters, spaces, are converted to periods.
  data <- utils::read.csv(file = input_file, sep = sep, stringsAsFactors = FALSE,
                          header = TRUE, check.names = TRUE, skip = 10)

  if (data[nrow(data),1] == "END OF FILE") {
    data <- data[-nrow(data),]
  }

  ## name of column 1 is changed to 'id'
  if (colnames(data)[1] == "X.") {colnames(data)[1] <- "id"}


  # TODO: decicde what to do about required columns for non-UAMS end users

  ## checks to make sure the input file contains the required annotation/contamination
  ## columns. This ensures that the file imported correctly and helps to identify
  ## sampleIDs columns and extract targets info. later.
  # if (!all(reqCols %in% colnames(data))) {
  #   missing_cols <- reqCols[reqCols %notin% colnames(data)]
  #   cli::cli_abort(c("Problem with columns in input file.",
  #                    "x" = "Required column(s) not present in {.file {input_file}}",
  #                    "x" = "Missing column{?s}: {missing_cols}"))
  # } else {
  #   cli::cli_inform("DIA protein file {.file {input_file}} imported")
  #   cli::cli_inform("Input file contains {num_input} protein entries")

  output <- data
  # }

  output
}



#' Extract protein data
#'
#' Third subfunction called by \code{\link{read_DIA_data}}. Processes the raw
#' protein annotation strings to extract standard gene names,
#' accession numbers, and Ids. FOR INTERNAL UAMS USE.
#'
#' @param annotation_data Annotation data from which to extract protein data.
#' @return A  data frame of cleaned up annotation data, with protein info
#'
#'
#' @keywords internal
#'
#' @examples
#' # No examples yet
extract_protein_data <- function(annotation_data) {

  ## extract gene name, gene symbol, and uniprot id info. from the Fasta.header
  ## append to qfilterData add unique protein ID (proKey = uniprot_GN_id
  annotation_data$Accession.Number <- gsub("(.+?)(\\ .*)","\\1", stringr::str_extract(annotation_data$Protein.Name,"(?<=\\|)[^\\|]+(?=\\ )"))
  annotation_data$UniprotID    <- stringr::str_extract(annotation_data$Protein.Name, "(?<=\\|)[^\\|]+(?=\\|)")
  annotation_data$Gene_name    <- stringr::str_extract(annotation_data$Protein.Name, "(?<=GN\\=)[^\\|]+(?= PE\\=)")
  annotation_data$Description  <- stringr::str_extract(annotation_data$Protein.Name, "(?<= )[^\\|]+(?= OS\\=)")

  annotColums <- diaAnnotationColums
  annotColums <- c(annotColums, "UniprotID", "Gene_name","Description")
  #rownames(annotation_data) <- paste(annotation_data$UniprotID, annotation_data$Gene_name, annotation_data$id, sep="_")

  annotation_data[, unique(c(annotColums, "UniprotID", "Gene_name","Description"))]
}


