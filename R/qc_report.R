#' Create quality control report
#'
#' Creates, and optionally saves as a PDF report, a bunch of plots which give
#' information on the distribution, clustering, and correlation of protein intensities
#' across samples for the chosen normalization method. By default, the PCA and
#' clustering analyses are performed on the top 500 most variable proteins. This
#' function is a wrapper that calls many subfunctions: \itemize{
#'   \item Makes boxplots of per-sample intensities
#'     with \code{\link{qc_boxplot}}.
#'   \item Makes violin plots of per-sample intensities
#'     with \code{\link{qc_violin_plot}}.
#'   \item Performs and plots a PCA with \code{\link{qc_pca_plot}}.
#'   \item Does hierarchical clustering and plots a dendrogram with
#'     \code{\link{qc_dendrogram}}.
#'   \item Plots a correlation heatmap with \code{\link{qc_corr_hm}}.
#' } See the documentation of these subfunctions for more info.
#'
#'
#' @inheritParams make_proteinorm_report
#' @param norm.method The normalization method for which to perform the QC analysis.
#'   Should be a name of one of the datasets in normList.
#' @param file The file name of the report to be saved. Must end in .pdf. Will
#'   default to "QC_Report.pdf" if no filename is provided.
#' @param legend Include legends in the plots within the report? Default is TRUE.
#' @param top.proteins The number of most variable proteins to use for the analysis.
#'   Default is 500.
#' @param stdize Should input data be standardized to a mean of 0 and std.dev of
#'   1? If input data are not yet standardized, should be TRUE. Default is TRUE.
#' @param pca.axes  A numeric vector of length 2 which lists the PC axes to plot.
#'   Default is c(1,2), to plot the first two principal components.
#' @param pca.xlim Optional. Custom x-axis limits of the PCA plot. By default,
#'   the min is 10% below the min PC score on the x-axis, and the max is above
#'   the max PC score on the x-axis, with some padding for sample labels.
#' @param pca.ylim Optional. Custom y-axis limits of the PCA plot. Default is
#'   10% above and below the min/max PC score on the y-axis.
#' @param pca.dot Character expansion factor for the size of the points in the
#'   PCA plot. Default is 2.
#' @inheritParams qc_dendrogram
#' @param clust.label.cex Character expansion factor for sample labels in the
#'   dendrogram. Default is 1.
#'
#' @return Invisibly returns a list with three slots: \enumerate{
#'   \item "plots"- A large list, where each element in the list is the returned
#'     object from the corresponding plotting function for that type of plot.
#'   \item "stats"- A dataframe with statistics on the data.
#'   \item "param"- A dataframe giving the parameters used for making the report.
#' }
#'
#' @export
#'
#' @examples
#' # No examples yet
#'
#'

# processed_data <- norm_lupashin
# grouping_column <- "group"
# chosen_norm_method <- "vsn"
# enrich <- "protein"
# label_column <- NULL
# out_dir <- NULL
# file <- NULL
# overwrite <- NULL

write_qc_report <- function(processed_data,
                            chosen_norm_method = NULL,
                            grouping_column = NULL,
                            label_column = NULL,
                            enrich = c("protein", "phospho"),
                            out_dir = NULL,
                            file = NULL,
                            overwrite = FALSE,
                            top_proteins = 500,
                            standardize = TRUE,
                            pca_axes = c(1,2),
                            clust_metric = "euclidean",
                            clust_method = "complete") {

  cli::cli_rule()

  #################
  ## Check args  ##
  #################

  # Check that processed_data has expected list structure
  if (!all(c("normList", "targets", "filt", "param", "stats") %in% names(processed_data))) {
    cli::cli_abort(c("{.arg processed_data} does not have expected structure:",
                     "i" = "Is it the object created by running {.code process_data()}?."))
  }

  # enrich: possible values encoded in function def
  enrich <- rlang::arg_match(enrich)

  # chosen_norm_method
  chosen_norm_method <- rlang::arg_match(
    arg = chosen_norm_method,
    values = unique(c(
      names(processed_data$normList), "log2", "median", "mean", "vsn", "quantile",
      "cycloess", "rlr", "gi"
    )), multiple = FALSE
  )

  # If provided, check that grouping column exists in the target dataframe
  # And set it
  if (!is.null(grouping_column)) {
    if (length(grouping_column) != 1) {
      cli::cli_abort(c("Length of {.arg grouping_column} does not equal 1",
                       "i" = "Only specify one column name for {.arg grouping_column}"))

    }
    if (grouping_column %notin% colnames(processed_data$targets)) {
      cli::cli_abort(c("Column {.arg {grouping_column}} not found in the targets dataframe of  in {.arg processed_data}",
                       "i" = "Check the column names with {.code colnames(processed_data$targets)}."))
    }
    groups <- processed_data$targets[,grouping_column]
  } else { # If no groups provided, set them but warn user
    groups <- rep("group", ncol(processed_data$normList[[chosen_norm_method]]))
    cli::cli_inform(cli::col_yellow("{.arg groups} argument is empty. Considering all samples/columns in {.arg processed_data} as one group."))
  }

  # If provided, check that label column is present in the target dataframe
  # and set it
  if (!is.null(label_column)) {
    if (length(label_column) != 1) {
      cli::cli_abort(c("Length of {.arg label_column} does not equal 1",
                       "i" = "Only specify one column name for {.arg label_column}"))

    }
    if (label_column %notin% colnames(processed_data$targets)) {
      cli::cli_abort(c("Column {.arg {label_column}} not found in the targets dataframe of  in {.arg processed_data}",
                       "i" = "Check the column names with {.code colnames(processed_data$targets)}."))
    }
    sample_labels <- processed_data$targets[,label_column]
  } else { # Use colnames of the normlist if not provided
    sample_labels <- colnames(processed_data$normList[[chosen_norm_method]])
  }

  ############
  ## SET UP ##
  ############

  # Set default dir if not provided
  if (is.null(out_dir)) {
    out_dir <- file.path(paste0(enrich, "_analysis"), "01_quality_control")
    cli::cli_inform(cli::col_yellow("{.arg dir} argument is empty. Setting output directory to: {.path {out_dir}}"))
  }

  # Set default report name if not provided
  if (is.null(file)) {
    file <- "QC_Report.pdf"
    cli::cli_inform(cli::col_yellow("{.arg file} argument is empty. Saving report to: {.path {out_dir}/{file}}"))
  }

  # Make directory if it doesn't exist
  if (!dir.exists(out_dir)) {
    dir.create(out_dir, recursive = T)
  }

  # Check that the filename is a pdf
  validate_filename(file, allowed_exts = c("pdf"))

  # Check if filename already exists
  if (file.exists(file.path(out_dir, file))) {
    if (overwrite) {
      cli::cli_inform("{.path {file}} already exists. {.arg overwrite} == {.val {overwrite}}. Overwriting.")
    } else {
      cli::cli_abort(c("{.path {file}} already exists in {.path {out_dir}}",
                       "!" = "and {.arg overwrite} == {.val {overwrite}}",
                       "i" = "Give {.arg file} a unique name or set {.arg overwrite} to {.val TRUE}"))
    }
  }


  # Select data from chosen normalization method for further use
  norm_data <- processed_data$normList[[chosen_norm_method]]

  #######################
  ## MAKE PLOT OBJECTS ##
  #######################

  # Violin plot
  violin <- qc_violin_plot(data = norm_data,
                           groups = groups,
                           sample_labels = sample_labels) +
    ggtitle(paste0("Grouped by ", grouping_column))



  # PCA

  # dendrogram

  # correlation heatmap

  # missing data heatmap - clustering and grouping by grouping column


  ###############################
  ## Save plots, check, return ##
  ###############################

  violin
}




make_qc_report <- function(normList,
                           groups = NULL, batch = NULL, sampleLabels = NULL,
                           norm.method = NULL, enrich = c("protein", "phospho"),
                           dir = NULL, file = NULL, save = TRUE,
                           overwrite = FALSE, keep.png = FALSE,
                           legend = TRUE,
                           top.proteins = 500, # Number of top variable proteins to include in PCA and dendrogram
                           stdize = TRUE,
                           pca.axes = c(1, 2),
                           pca.xlim = NULL, pca.ylim = NULL, pca.dot = 2,
                           clust.metric = "euclidean", clust.method = "complete",
                           clust.label.cex = 1
                           ) {



  ##################
  ## Create plots ##
  ##################

  # Set up widths
  # Will make individual for now, so we can fine tune if needed
  if (save) {
    width_box <- round(0.0191 * length(groups)^2 + 12.082 * length(groups) + 671.75, 0)
    width_vio <- round(0.0191 * length(groups)^2 + 12.082 * length(groups) + 671.75, 0)
    width_pca <- 750
    width_dendro <- round(0.0191 * length(groups)^2 + 12.082 * length(groups) + 671.75, 0)
    if (length(groups) < 100) {
      width_cor <- round(0.0871 * length(groups)^2 + 24.375 * length(groups) + 473.02, 0)
    } else {
      width_cor <- round((0.0035 * length(groups)^2 + 10.035 * length(groups) + 146.15)*1.3, 0)
    }
  }

  ####
  ## BOXPLOT(S)
  ####

  if (save) {
    # Open Graphics device for main plot
    grDevices::png(
      filename = file.path(out_dir, "BoxPlot.png"), units = "px",
      width = width_box, height = 750, pointsize = 15
    )
  }
  # Group boxplot
  box <- qc_boxplot(data = data,
                    groups = groups,
                    sampleLabels = sampleLabels,
                    title = "Grouped by group",
                    legend = legend)
  if (save) grDevices::dev.off()

  # If plotting by batch
  if (!is.null(batch)) {
    if (save) {
      grDevices::png(
        filename = file.path(out_dir, "BoxPlot2.png"), units = "px",
        width = width_box, height = 750, pointsize = 15
      )
    }
    box2 <- qc_boxplot(data = data,
                       groups = batch,
                       sampleLabels = sampleLabels,
                       title = "Grouped by batch",
                       legend = legend)
    if (save) grDevices::dev.off()
  }

  ####
  ## VIOLIN PLOT(S)
  ####
  if (save) {
    grDevices::png(
      filename = file.path(out_dir, "ViolinPlot.png"), units = "px",
      width = width_vio, height = 750, pointsize = 15)
  }
  # Main group plot
  vio <- qc_violin_plot(data,
                        groups = groups,
                        sampleLabels,
                        title = "Grouped by group",
                        legend)
  if (save) grDevices::dev.off()

  if (!is.null(batch)) {
    if (save) {
      grDevices::png(filename = file.path(out_dir, "ViolinPlot2.png"),
          units = "px", width = width_vio, height = 750, pointsize = 15)
    }
    vio2 <- qc_violin_plot(data = data,
                           groups = batch,
                           sampleLabels = sampleLabels,
                           title = "Grouped by batch",
                           legend = legend)
    if (save) grDevices::dev.off()
  }


  ####
  ## PCA PLOT(S)
  ####
  if (save) {
    grDevices::png(filename = file.path(out_dir, "PCAplot.png"), units = "px",
      width = width_pca, height = 650, pointsize = 15)
  }
  pca <- qc_pca_plot(
    data = data, groups = groups, sampleLabels = sampleLabels,
    title = "PCA, colored by group",
    top = top.proteins, stdize = stdize, dims = pca.axes,
    cex.dot = pca.dot, xlim = pca.xlim, ylim = pca.ylim,
    legend = legend)
  if (save) grDevices::dev.off()


  if (!is.null(batch)) {
    if (save) {
      grDevices::png(filename = file.path(out_dir, "PCAplot2.png"), units = "px",
                     width = width_pca, height = 650, pointsize = 15)
    }
    pca2 <- qc_pca_plot(
      data = data, groups = batch, sampleLabels = sampleLabels,
      title = "PCA, colored by batch",
      top = top.proteins, stdize = stdize, dims = pca.axes,
      cex.dot = pca.dot, xlim = pca.xlim, ylim = pca.ylim,
      legend = legend)
    if (save) grDevices::dev.off()
  }

  ####
  ## DENDROGRAM(S)
  ####
  if (save) {
    grDevices::png(filename = file.path(out_dir, "Dendrogram.png"), units = "px",
      width = width_dendro, height = 650, pointsize = 15)
  }
  dendro <- qc_dendrogram(
    data = data, groups = groups, sampleLabels = sampleLabels,
    top = top.proteins, stdize = stdize,
    clust.metric = clust.metric, clust.method = clust.method,
    cex.names = clust.label.cex,
    title = paste0("Method: ", clust.method, ". Metric: ", clust.metric, "\nColored by group"),
    legend = legend
  )
  if (save) grDevices::dev.off()
  if (!is.null(batch)) {
    if (save) {
      grDevices::png(filename = file.path(out_dir, "Dendrogram2.png"), units = "px",
                     width = width_dendro, height = 650, pointsize = 15)
    }
    dendro2 <- qc_dendrogram(
      data = data, groups = batch, sampleLabels = sampleLabels,
      top = top.proteins, stdize = stdize,
      clust.metric = clust.metric, clust.method = clust.method,
      cex.names = clust.label.cex,
      title = paste0("Method: ", clust.method, ". Metric: ", clust.metric, "\nColored by batch"),
      legend = legend
      )
    if (save) grDevices::dev.off()
  }

  ####
  ## HEATMAP(S)
  ####
  if (save) {
    grDevices::png(filename = file.path(out_dir, "CorrHeatmap.png"), units = "px",
      width = width_cor, height = width_cor, pointsize = 15)
  }
  corhm <- qc_corr_hm(data = data,
                     groups = groups, batch = batch, sampleLabels = sampleLabels)
  if (save) grDevices::dev.off()


  ##################
  ## Save report  ##
  ##################
  if (save) {

    cli::cli_inform("Saving report to: {.path {file.path(out_dir, file)}}")

    ##  MAKE PDF FILE
    grDevices::pdf(file.path(out_dir, file), paper = "USr", pagecentre = TRUE, pointsize = 15, width = 12, height = 8)

    if (is.null(batch)) {
      files <- c("BoxPlot.png", "ViolinPlot.png", "PCAplot.png", "Dendrogram.png", "CorrHeatmap.png")
    } else {
      files <- c("BoxPlot.png", "BoxPlot2.png", "ViolinPlot.png",
                 "ViolinPlot2.png", "PCAplot.png", "PCAplot2.png",
                 "Dendrogram.png", "Dendrogram2.png", "CorrHeatmap.png")
    }

    # Collect pngs as plot objects
    pnglist <- paste0(paste0(file.path(out_dir), "/"), files)
    thePlots <- lapply(1:length(pnglist), function(i) {
      grid::rasterGrob(png::readPNG(pnglist[i], native = F))
    })

    if (ncol(data) <= 50) { # When project is small enough
        # Put first 4 plots onto the first page
        gridExtra::grid.arrange(grobs = thePlots[1:4], ncol = 2)
        # And plot the next 4 plots on another page when batch
        if (!is.null(batch)) {
          gridExtra::grid.arrange(grobs = thePlots[5:8], ncol = 2)
        }
    }

    # Print all plots on their own page
    lapply(X = thePlots, FUN = gridExtra::grid.arrange, ncol = 1)
    grDevices::dev.off()

    # Deal with the .png files
    if (!keep.png) { # Delete
      unlink(pnglist)
      cli::cli_inform("Temporary {.path .png} files removed from {.path {out_dir}} ")
    } else { # Move to a new png directory
      # Setup dir name
      pngdir <- gsub(".pdf", "_pngs", file)
      # Create if it doesn't exist
      if (!dir.exists(file.path(out_dir, pngdir))) {
        dir.create(file.path(out_dir, pngdir), recursive = TRUE)
      }
      # Move files
      lapply(pnglist, function(x) {
        file.copy(from = x, to = file.path(out_dir, pngdir, basename(x)))
        file.remove(x)
      })
    }
  }

  ##############
  ## Logging  ##
  ##############
  param <- stats <- list()
  param[["norm.method"]] <- norm.method
  param[["batch"]] <- ifelse(is.null(batch), "NULL", paste(unique(batch), collapse = ", "))
  param[["stdize"]] <- stdize
  param[["top.proteins"]] <- top.proteins
  param[["dims"]] <- paste(pca.axes, collapse = ", ")
  param[["clust.metric"]] <- clust.metric
  param[["clust.method"]] <- clust.method
  param[["dir"]] <- ifelse(save, out_dir, NA)
  param[["file"]] <- ifelse(save, file, NA)
  param[["png.dir"]] <- ifelse(keep.png, pngdir, NA)
  param[["enrich"]] <- enrich

  stats[["num_samples"]] <- ncol(data)
  stats[["num_groups"]] <- length(unique(groups))
  stats[["num_batches"]] <- ifelse(is.null(batch), 0, length(unique(batch)))
  stats[["total_num_rows"]] <- nrow(data)
  stats[["top_num_rows"]] <- top.proteins

  logs <- make_log(param, stats, title = "QC REPORT", save = TRUE)


  ###############
  ## Returning ##
  ###############
  if (is.null(batch)) {
    plotList <- list(
      box = box, violin = vio, pca = pca, dendro = dendro, corr_hm = corhm
    )
  } else {
    plotList <- list(
      box_group = box, box_batch = box2,
      violin_group = vio, violin_batch = vio2,
      pca_group = pca, pca_batch = pca2,
      dendro_group = dendro, dendro_batch = dendro2,
      corr_hm = corhm
    )
  }

  output_data <- list(plots = plotList, stats = logs$stats, param = logs$param)

  cli::cli_rule()
  cli::cli_inform(c("v" = "Success"))

  invisible(output_data)
}
